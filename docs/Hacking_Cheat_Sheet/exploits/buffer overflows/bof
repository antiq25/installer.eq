https://en.wikipedia.org/wiki/Buffer_overflow

buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites memory in adjacent locations. This is a special case of the violation of memory safety.

Buffer overflows can be triggered by inputs that are designed to execute code, or alter the way the program operates. This may result in erratic program behavior, including memory access errors, incorrect results, a crash, or a breach of system security. Thus, they are the basis of many software vulnerabilities and can be maliciously exploited.

The techniques to exploit a buffer overflow vulnerability vary by architecture, by operating system and by memory region. For example, exploitation on the heap (used for dynamically allocated memory), differs markedly from exploitation on the call stack.

Stack-based exploitation - Stack buffer overflow

A technically inclined user may exploit stack-based buffer overflows to manipulate the program to their advantage in one of several ways:

by overwriting a local variable that is near the buffer in memory on the stack to change the behavior of the program - which may benefit the attacker.
by overwriting the return address in a stack frame. Once the function returns, execution will resume at the return address as specified by the attacker, usually a user-input filled buffer.
by overwriting a function pointer[1] or exception handler, which is subsequently executed
by overwriting a parameter of a different stack frame or a non-local address pointed to in the current stack context[2]

Programming languages commonly associated with buffer overflows include C and C++, which provide no built-in protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array. 



Bounds checking can prevent buffer overflows.



[SOURCE CODE]

================
VULNERABLE CODE
================

/* overflow.c - demuestra un desbordamiento de buffer */

#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
  char buffer[10];
  if (argc < 2)
  {
    fprintf(stderr, "MODO DE USO: %s string\n", argv[0]);
    return 1;
  }
  strcpy(buffer, argv[1]);
  return 0;
}

=============
SECURE CODE
=============

/* mejor.c - demuestra un método de resolver el problema */

#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
  char buffer[10];
  if (argc < 2)
  {
    fprintf(stderr, "MODO DE USO: %s string\n", argv[0]);
    return 1;
  }
  strncpy(buffer, argv[1], sizeof(buffer));
  buffer[sizeof(buffer) - 1] = '\0';
  return 0;
}

================
VULNERABLE CODE
================

#include <stdio.h>
#include <string.h>
int main( int argc, char *argv[] )
{
  // Buffer estático en la pila.
  char buffer[1024];
  if ( argc != 2 )
  {
    printf("Uso: %s argumento\n", argv[0] );
    return( -1 );
  }
  // Copiado de cadenas sin control.
  strcpy( buffer, argv[1]);
  printf( "Argumento copiado\n" );
  return(0);
}